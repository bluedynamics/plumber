Plumbings in conjunction to extensions (or defaults)

+---------------+-------------------------------------------------+
|               |  EXTEND ENDPOINT RESOLUTION                     |
+---------------+---------+---------+---------+---------+---------+
| Endpoints     |  x(p)   |  y(p1)  |  z(p2)  |  w(p3)  |  v(p4)  |
+---------------+---------+---------+---------+---------+---------+
| Plumbing      |  x(p)   |         |         |         |         |
+---------------+---------+---------+---------+---------+---------+
| Part1         |         |  y(p1)  |         |         |         |
+---------------+---------+---------+---------+---------+---------+
| Part2         |         |         |  z(p2)  |         |         |
+---------------+---------+---------+---------+---------+---------+
| Part3         |         |         |         |  w(p3)  |         |
+---------------+---------+---------+---------+---------+---------+
| Base          |  x(b)   |  y(b)   |  z(b)   |  w(b)   |  v(b)   |
+---------------+---------+---------+---------+---------+---------+

+---------------+-------------------------------------------------+
|               |  PLUMBING RESOLUTION                            |
+---------------+---------+---------+---------+---------+---------+
| Endpoints     |  x(p)   |  y(p1)  |  z(p2)  |  w(p3)  |  v(b)   |
+---------------+---------+---------+---------+---------+---------+
| Part1         |  x      |         |  z      |         |         |
+---------------+---------+---------+---------+---------+---------+
| Part2         |         |  y      |         |         |         |
+---------------+---------+---------+---------+---------+---------+
| Part3         |         |         |  z      |         |         |
+---------------+---------+---------+---------+---------+---------+

Wichtig zu kommunizieren: Resolution Order:

(1) Endpoints -> (2) Plumbings

Die Pipeline wird in 2 Schritten aufgelÃ¶st, die nacheinander anzusehen sind. 

Erst wird durch die pipeline hindurch der endpoint gesucht, dies
betrifft
a) classmethods auf Base und Plumbing
b) extends
c) defaults

Mit diesem gefundenen Endpoint wird das Plumbing aufgebaut.



###

Thus, plumbing which works orthogonal
to subclassing: It uses a chain of closures.

The plumber provides declaritive extension of classes. A class declares parts
in a pip


Plumbing only works within one class, as if declared on the class. default and
extend don't take base class attr into account, they are checked if

A metaclass creates classes, it works on them right after they are declared.

A class that would like the plumber to extend it, declares a pipeline of parts.
The parts are in an ordered list, they contain code with instructions on how to
extend the class. A class using a plumber is called a plumbing.

By that a

plumber, a metaclass, extends a class with parts declared in its pipeline.


by parts, declared


plumber is a metaclass that implements plumbing which is an alternative to
subclassing works orthogonal
to subclassing: It uses a chain of closures



A class declares ``plumber`` as ``__metaclass__`` and a
``__plumbing__`` of parts that will be used for the plumbing. A plumbing
limited to the class declaring

Parts carry instructions and instructions carry code and tell what to do with
it.


form the plumbing system. Parts can extend
classes as if the
code was declared on the class itself (``extend`` decorator), provide default
values for class variables (``default`` decorator) and form chains of methods
(``plumb`` decorator) that pre-process parameters before passing them to the
next method and post-process results before passing them to the previous method
(similar to WSGI pipelines).

Why not just use sub-classing? see Motivation::

    >>> from plumber import plumber
    >>> from plumber import Part
    >>> from plumber import default
    >>> from plumber import extend
    >>> from plumber import plumb

The plumber is aware of ``zope.interface`` but does not require it (see
``zope.interface support``)


Resolution Matrix
=================

A way to describe plumbings: In parens ``()`` are the base classes used for
the plumbing and in brackets ``[]`` the plumbing parts.

Plb[P2, P1](Base) == Plb[P2](Plb[P1](Base))

In code:

A base class and three parts::

    >>> class Base(object):
    ...     pass

    >>> class P1(Part):
    ...     pass

    >>> class P2(Part):
    ...     pass

    >>> class P3(Part):
    ...     pass

A plumbing derived from Base using P1::

    >>> class Plb1(Base):
    ...     __metaclass__ = plumber
    ...     __plumbing__ = P1

A plumbing derived from Plb1 using P2...::

    >>> class Plb2_1(Plb1):
    ...     __metaclass__ = plumber
    ...     __plumbing__ = P2

...and a plumbing derived from Base using P2 and P1..::

    >>> class Plb21(Base):
    ...     __metaclass__ = plumber
    ...     __plumbing__ = P2, P1

...should be the same::

    >>> #Plb2_1 == Plb21


``@default``::

    +---------------+-----+-----+-----+-----+
    |               |        ENDPOINT       |
    +---------------+-----+-----+-----+-----+
    | PlumbingClass |     | (y) |     |     |
    +---------------+-----+-----+-----+-----+
    | A             | (x) |     |     |     |
    +---------------+-----+-----+-----+-----+
    | B             |  x  |  y  |     |     |
    +---------------+-----+-----+-----+-----+
    | C             |     |     | (z) |     |
    +---------------+-----+-----+-----+-----+
    | Bases         |  x  |  y  |  z  | (w) |
    +---------------+-----+-----+-----+-----+

XXX: proposal - currently implemented - enables easy dict nodification, see
(node.parts.mapping.txt and node.parts.nodify.txt::

    +---------------+-----+-----+-----+-----+
    |               |        ENDPOINT       |
    +---------------+-----+-----+-----+-----+
    | PlumbingClass | (x) |     |     |     |
    +---------------+-----+-----+-----+-----+
    | Bases         |  x  | (y) |     |     |
    +---------------+-----+-----+-----+-----+
    | A             |  x  |  y  | (z) |     |
    +---------------+-----+-----+-----+-----+
    | B             |  x  |  y  |  z  | (w) |
    +---------------+-----+-----+-----+-----+

``@extend``::

    +---------------+-----------------------------+
    |               |          ENDPOINT           |
    +---------------+-----+-----+-----+-----+-----+
    | PlumbingClass | (X) |     |     |     |     |
    +---------------+-----+-----+-----+-----+-----+
    | A             |     | (y) |     |     |     |
    +---------------+-----+-----+-----+-----+-----+
    | B             |     |     | (z) |     |     |
    +---------------+-----+-----+-----+-----+-----+
    | C             |     |     |     | (w) |     |
    +---------------+-----+-----+-----+-----+-----+
    | Bases         |  x  |  y  |  z  |  w  | (v) |
    +---------------+-----+-----+-----+-----+-----+

``@plumb``::

    +---+---+---+---+----------+
    |   | A | B | C | ENDPOINT |
    +---+---+---+---+----------+
    |   |  ---------->         |
    | E | x |   |   | x        |
    | N |  <----------         |
    + T +---+---+---+----------+
    | R |  --> ------>         |
    | A | y | y |   | y        |
    | N |  <-- <------         |
    + C +---+---+---+----------+
    | E |   |   |  -->         |
    |   |   |   | z | z        |
    |   |   |   |  <--         |
    +---+---+---+---+----------+


Discussions
-----------

Where is the plumbing
~~~~~~~~~~~~~~~~~~~~~
It is in front of the class and its MRO. If you feel it should be between the
class and its base classes, consider subclassing the class that uses the
plumbing system and put your code there. If you have a strong point why this is
not a solution, please let us know. However, the point must be stronger than
saving 3 lines of which two are pep8-conform whitespace.

Signature of _next function
~~~~~~~~~~~~~~~~~~~~~~~~~~~
Currently ``self`` needs to be passed to the ``_next`` function. This could be
wrapped, too. However, it might enable cool stuff, because you can decide to
pass something else than self to be processed further.

Implementation of this would slightly increase the complexity in the plumber,
result in less flexibility, but save passing ``self`` to ``_next``.

Instance based plumbing system
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
At various points it felt tempting to be able to instantiate plumbing elements
to configure them. For that we need ``__init__``, which woul mean that plumbing
``__init__`` would need a different name, eg. ``prt_``-prefix. Consequently
this could then be done for all plumbing methods instead of decorating them.
The decorator is really just used for marking them and turning them into
classmethods. The plumbing decorator is just a subclass of the classmethod
decorator.

Reasoning why currently the methods are not prefixed and are classmethods:
Plumbing elements are simply not meant to be normal classes. Their methods have
the single purpose to be called as part of some other class' method calls,
never directly. Configuration of plumbing elements can either be achieved by
subclassing them or by putting the configuration on the objects/class they are
used for.

The current system is slim, clear and easy to use. An instance based plumbing
system would be far more complex. It could be implemented to exist alongside
the current system. But it won't be implemented by us, without seeing a real use
case first.

Different zope.interface.Interfaces for plumbing and created class
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
A different approach to the currently implemented system is having different
interfaces for the parts and the class that is created::

    #    >>> class IPart1Behaviour(Interface):
    #    ...     pass
    #
    #    >>> class Part1(Part):
    #    ...     implements(IPart1)
    #    ...     interfaces = (IPart1Behaviour,)
    #
    #    >>> class IPart2(Interface):
    #    ...     pass
    #
    #    >>> class Part2(Part):
    #    ...     implements(IPart2)
    #    ...     interfaces = (IPart2Behaviour,)
    #
    #    >>> IUs.implementedBy(Us)
    #    True
    #    >>> IBase.implementedBy(Us)
    #    True
    #    >>> IPart1.implementedBy(Us)
    #    False
    #    >>> IPart2.implementedBy(Us)
    #    False
    #    >>> IPart1Behaviour.implementedBy(Us)
    #    False
    #    >>> IPart2Behaviour.implementedBy(Us)
    #    False

Same reasoning as before: up to now unnecessary complexity. It could make sense
in combination with an instance based plumbing system and could be implemented
as part of it alongside the current class based system.

Implicit subclass generation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Currently the whole plumbing system is implemented within one class that is
based on the base classes defined in the class declaration. During class
creation the plumber determines all functions involved in the plumbing,
generates pipelines of methods and plumbs them together.

An alternative approach would be to take one plumbing elements after another
and create a subclass chain. However, I currently don't know how this could be
achieved, believe that it is not possible and think that the current approach
is better.

Dynamic Plumbing
~~~~~~~~~~~~~~~~
The plumber could replace the ``__plumbing__`` attribute with a property of the
same name. Changing the attribute during runtime would result in a plumbing
specific to the object. A plumbing cache could further be used to reduce the
number of plumbing chains in case of many dynamic plumbings. Realised eg by a
descriptor.